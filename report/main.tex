\documentclass[a4paper,11pt]{article}
\usepackage[francais]{babel} % Package babel pour le français
\usepackage[T1]{fontenc}    % Package pour les accentuations
\usepackage[utf8]{inputenc}  % Français
\usepackage{geometry}       % Utilisé pour les marges
\usepackage{algorithm}
\usepackage{algpseudocode}

\geometry{hmargin=2cm,vmargin=2cm} % Réglages des marges

% Titre du document, dates, auteurs
\title{
\normalfont \normalsize
\textsc{Université de Technologie de Compiègne\\
TX - Étude expérimentale} \\
[10pt]
\rule{\linewidth}{0.5pt} \\[6pt]
\huge Éxploitation de données pour algorithmes de graphes multimodaux \\
\rule{\linewidth}{0.5pt}  \\[10pt]
}
\author{Jing Li \& Henri Lefebvre}
\date{\normalsize Printemps 2018}

\begin{document}
\maketitle
\noindent
\tableofcontents
\newpage

\section{Formats de données standards}
\subsection{Formats NTFS et GTFS}
Présentation de chaque fichier
\subsection{Réduction des données}
Ne garder que le centre de Paris

\section{Modèles sans dépendances temporelles}
\subsection{Représentation}
\textit{Time independant model} principalement pour les réseaux routiers
\subsection{Algorithme de Dijkstra}
Parler des améliorations qui existent
\subsection{Algorithme de Bellman-Ford}
\begin{algorithm}[H]
  \caption{Algorithme de Bellman-Ford}\label{bellman}
  \begin{algorithmic}[1]
    \Procedure{Bellman-Ford}{$G=(V,E,w), s$}
      \Statex\Comment{Initialisation}
      \ForAll{sommet $v\in V$}
        \State $d[v]\gets\infty$
        \State $\pi[v]\gets$NIL
      \EndFor
      \State $d[s]\gets 0$
      \Statex\Comment{Calcul du plus cours chemin}
      \For{$i$ de 1 à $|V|-1$}
        \ForAll{arc $(u,v)\in E$}
          \If{$d[v] > d[u]+w(u,v)$}
            \State $d[v]\gets d[u]+w(u,v)$
            \State $\pi[v]\gets u$
          \EndIf
        \EndFor
      \EndFor
      \Statex
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

Remarque : on peut aider bellman en triant les distances et on s'arrête dès qu'aucun changement n'a été fait lors d'une itération.
Dans le pire des cas, cela ne change rien, mais sur nos données c'est assez pertinent...

\section{Modèles avec dépendances temporelles}
\subsection{Représentation}
\subsubsection{\textit{Condensed Model}}
Utiliser le min pour chaque arc, ça donne une borne inférieure (donc pas de résultat exact) mais le graph est petit
\subsubsection{\textit{Time-expanded Model}}
Les noeuds sont des evenements : $(S_1,S_2,\tau_1,\tau_2)$ : Départ de $S_1$ à $\tau_1$ pour une arrivée à $S_2$ en $\tau_2$\\
Pour les transferts on ajoute : stop\_1 = from\_stop\_id, stop\_2 = to\_stop\_id, arrivée(stop\_1), arrivée(stop\_1) + min\_transfer\_time
pour tous les départ en stop\_1 possible (donc complexité mémoire un peu pourri...)

% \subsection{Algorithme de Dijkstra (?)}
\subsection{Algorithme de Bellman-Ford}

Grâce au \textit{DataStore} on stock en définitif pour bellman que $n_s$ (= nombre de noeuds dans la composante connexe du stop de départ)

\subsubsection{Bellman-Ford réparti}
Comme $O(nm)$ et $m >> n$ on pourrait faire du bellman réparti dans la deuxième boucle en mode "map-reduce"\\
chaque noeud réparti traite un sous ensemble des arcs (map) puis on collecte les resultats (qui sont de la taille de la composante connexe du noeud de départ)
et on calcul les min des meilleurs résultats trouvés par chacun des noeuds (reduce).

\end{document}
